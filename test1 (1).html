<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>电路设计平台</title>
    <link rel="stylesheet" href="extracted-styles.css">
    <!-- 引入磁吸功能 -->
    <script src="magnetic-snap.js"></script>
    <!-- 引入手势控制功能 -->
    <script src="gesture-control.js"></script>
    <!-- 引入打开功能 -->
    <script src="open.js"></script>
    <!-- 引入保存功能 -->
    <script src="save.js"></script>
    <!-- 引入按钮元件 -->
    <link rel="stylesheet" href="push-button.css">
    <script src="push-button.js"></script>
    <!-- 引入开关元件 -->
    <link rel="stylesheet" href="switch.css">
    <script src="switch.js"></script>
</head>

<body>
    <div class="nav">
        <ul class="navlist">
            <li class="btli"><a href="#">文件(F)</a>
                <ul class="droplist">
                    <li><a href="#">打开</a></li>
                    <li><a href="#">保存</a></li>
                    <li><a href="#">另存为</a></li>
                    <li><a href="#">新建</a></li>
                    <li><a href="#">退出</a></li>
                </ul>
            </li>
            <li class="btli"><a href="#">编辑(E)</a>
                <ul class="droplist">
                    <li><a href="#">撤销</a></li>
                    <li><a href="#">剪切</a></li>
                    <li><a href="#">复制</a></li>
                    <li><a href="#">粘贴</a></li>
                    <li><a href="#">删除</a></li>
                </ul>
            </li>
            <li class="btli"><a href="#">视图(V)</a>
                <ul class="droplist">
                    <li><a href="#">全屏</a></li>
                    <li><a href="#">放大</a></li>
                    <li><a href="#">缩小</a></li>
                    <li><a href="#">边界</a></li>
                    <li><a href="#">工具栏</a></li>
                </ul>
            </li>
            <li class="btli"><a href="#">绘制(P)</a>
                <ul class="droplist">
                    <li><a href="#">元器件</a></li>
                    <li><a href="#">导线</a></li>
                    <li><a href="#">总线</a></li>
                    <li><a href="#">结</a></li>
                    <li><a href="#">连接器</a></li>
                </ul>
            </li>
            <li class="btli"><a href="#">工具(T)</a>
                <ul class="droplist">
                    <li><a href="#">元器件向导</a></li>
                    <li><a href="#">电路向导</a></li>
                    <li><a href="#">数据库</a></li>
                    <li><a href="#">清除</a></li>
                    <li><a href="#">切换</a></li>
                </ul>
            </li>
        </ul>
    </div>

    <!-- 快捷工具栏 -->
    <div class="toolbar-container">
        <div class="quick-toolbar">
            <!-- 文字工具 -->
            <div class="toolbar-item" data-tool="text" title="文字工具">
                <svg viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                    <path d="M5,4V7H10.5V19H13.5V7H19V4H5Z"/>
                </svg>
                <div class="tooltip">文字工具</div>
            </div>

            <div class="toolbar-separator"></div>

            <!-- 输入端口 -->
            <div class="toolbar-item" data-tool="input" title="输入端口">
                <svg viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                    <rect x="4" y="8" width="12" height="8" rx="2" fill="#006400" stroke="black" stroke-width="1"/>
                    <text x="10" y="13" font-family="Arial" font-size="6" fill="white" text-anchor="middle">I</text>
                    <circle cx="18" cy="12" r="2" fill="black"/>
                </svg>
                <div class="tooltip">输入端口</div>
            </div>

            <!-- 输出端口 -->
            <div class="toolbar-item" data-tool="output" title="输出端口">
                <svg viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                    <circle cx="6" cy="12" r="2" fill="black"/>
                    <rect x="8" y="8" width="12" height="8" rx="2" fill="#008000" stroke="black" stroke-width="1"/>
                    <text x="14" y="13" font-family="Arial" font-size="6" fill="white" text-anchor="middle">O</text>
                </svg>
                <div class="tooltip">输出端口</div>
            </div>

            <div class="toolbar-separator"></div>

            <!-- 与门 -->
            <div class="toolbar-item" data-tool="and-gate" title="与门">
                <svg viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="1.5" width="24" height="24">
                    <path d="M4 8 L12 8 A6 6 0 0 1 12 16 L4 16 Z"/>
                    <circle cx="2" cy="10" r="1" fill="black"/>
                    <circle cx="2" cy="14" r="1" fill="black"/>
                    <circle cx="20" cy="12" r="1" fill="black"/>
                </svg>
                <div class="tooltip">与门</div>
            </div>

            <!-- 或门 -->
            <div class="toolbar-item" data-tool="or-gate" title="或门">
                <svg viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="1.5" width="24" height="24">
                    <path d="M4 8 Q12 8 18 12 Q12 16 4 16 Q8 12 4 8"/>
                    <circle cx="2" cy="10" r="1" fill="black"/>
                    <circle cx="2" cy="14" r="1" fill="black"/>
                    <circle cx="20" cy="12" r="1" fill="black"/>
                </svg>
                <div class="tooltip">或门</div>
            </div>

            <!-- 非门 -->
            <div class="toolbar-item" data-tool="not-gate" title="非门">
                <svg viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="1.5" width="24" height="24">
                    <path d="M4 8 L16 12 L4 16 Z"/>
                    <circle cx="17" cy="12" r="1.5" fill="none"/>
                    <circle cx="2" cy="12" r="1" fill="black"/>
                    <circle cx="20" cy="12" r="1" fill="black"/>
                </svg>
                <div class="tooltip">非门</div>
            </div>


        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <h3>电路元件库</h3>

            <div class="component-list">
                <details>
                    <summary>逻辑门</summary>
                    <ul>
                        <li data-type="and-gate">与门</li>
                        <li data-type="or-gate">或门</li>
                        <li data-type="not-gate">非门</li>
                        <li data-type="xor-gate">异或门</li>
                        <li data-type="nand-gate">与非门</li>
                    </ul>
                </details>
            </div>

            <div class="component-list">
                <details>
                    <summary>时序逻辑</summary>
                    <ul>
                        <li data-type="d-flipflop">D触发器</li>
                    </ul>
                </details>
            </div>

            <div class="component-list">
                <details>
                    <summary>输入输出</summary>
                    <ul>
                        <li data-type="input">输入端口</li>
                        <li data-type="output">输出端口</li>
                        <li data-type="clock">时钟信号</li>
                        <li data-type="push-button">按钮</li>
                        <li data-type="switch">开关</li>
                    </ul>
                </details>
            </div>

            <div class="component-list">
                <details>
                    <summary>运算器</summary>
                    <ul>
                        <li data-type="adder">加法器</li>
                        <li data-type="subtractor">减法器</li>
                        <li data-type="divider">除法器</li>
                        <li data-type="complement">求补器</li>
                    </ul>
                </details>
            </div>
        </div>

        <div class="canvas-container">
            <div class="canvas" id="circuit-canvas">
                <svg id="wire-layer" xmlns="http://www.w3.org/2000/svg"></svg>
            </div>
        </div>

        <!-- 右键菜单 -->
        <div id="context-menu" class="context-menu">
            <div class="context-menu-item" id="delete-item">
                <span class="danger">删除</span>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const canvas = document.getElementById('circuit-canvas');
            const wireLayer = document.getElementById('wire-layer');
            const componentItems = document.querySelectorAll('.component-list li');
            const contextMenu = document.getElementById('context-menu');
            const deleteItem = document.getElementById('delete-item');
            const toolbarItems = document.querySelectorAll('.toolbar-item');
            let startAnchor = null;
            let currentTool = null;

            // 初始化磁吸功能
            const magneticSnap = new MagneticSnap({
                gridSize: 20,           // 与CSS网格大小一致
                snapDistance: 15,       // 网格磁吸距离
                anchorSnapDistance: 50, // 锚点磁吸距离（增加到50像素，更容易连接）
                enabled: true           // 默认启用
            });

            // 初始化手势控制功能
            const gestureControl = new GestureControl();

            // 监听手势模式变化
            document.addEventListener('gestureMode', function(e) {
                const { mode, isGrabMode, isConnectMode } = e.detail;
                console.log('手势模式变化:', mode);

                // 显示模式提示
                gestureControl.showModeHint();

                // 根据模式调整交互行为
                if (isConnectMode) {
                    // 连线模式：禁用组件拖拽，启用连线功能
                    canvas.classList.add('connect-mode');
                } else {
                    // 抓取模式：启用组件拖拽，正常操作
                    canvas.classList.remove('connect-mode');
                }
            });
            // 存储所有连线与锚点的关联关系
            const wires = [];

            // 创建带转弯的连线
            function createBentWire(startX, startY, endX, endY) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'wire');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', 'black');
                path.setAttribute('stroke-width', '2');

                // 计算转弯路径
                const pathData = calculateBentPath(startX, startY, endX, endY);
                path.setAttribute('d', pathData);

                return path;
            }

            // 计算转弯路径
            function calculateBentPath(startX, startY, endX, endY) {
                const dx = endX - startX;
                const dy = endY - startY;

                // 如果距离很近，使用直线
                if (Math.abs(dx) < 50 && Math.abs(dy) < 50) {
                    return `M ${startX} ${startY} L ${endX} ${endY}`;
                }

                // 计算中间转弯点
                let midX, midY;

                // 根据相对位置决定转弯方式
                if (Math.abs(dx) > Math.abs(dy)) {
                    // 水平距离更大，先水平后垂直
                    midX = startX + dx * 0.7;
                    midY = startY;
                } else {
                    // 垂直距离更大，先垂直后水平
                    midX = startX;
                    midY = startY + dy * 0.7;
                }

                // 创建带圆角的路径
                const cornerRadius = 10;

                if (Math.abs(dx) > Math.abs(dy)) {
                    // 水平优先路径
                    if (dx > 0) {
                        // 向右
                        if (dy > 0) {
                            // 向下
                            return `M ${startX} ${startY} L ${midX - cornerRadius} ${startY} Q ${midX} ${startY} ${midX} ${startY + cornerRadius} L ${midX} ${endY - cornerRadius} Q ${midX} ${endY} ${midX + cornerRadius} ${endY} L ${endX} ${endY}`;
                        } else {
                            // 向上
                            return `M ${startX} ${startY} L ${midX - cornerRadius} ${startY} Q ${midX} ${startY} ${midX} ${startY - cornerRadius} L ${midX} ${endY + cornerRadius} Q ${midX} ${endY} ${midX + cornerRadius} ${endY} L ${endX} ${endY}`;
                        }
                    } else {
                        // 向左
                        if (dy > 0) {
                            // 向下
                            return `M ${startX} ${startY} L ${midX + cornerRadius} ${startY} Q ${midX} ${startY} ${midX} ${startY + cornerRadius} L ${midX} ${endY - cornerRadius} Q ${midX} ${endY} ${midX - cornerRadius} ${endY} L ${endX} ${endY}`;
                        } else {
                            // 向上
                            return `M ${startX} ${startY} L ${midX + cornerRadius} ${startY} Q ${midX} ${startY} ${midX} ${startY - cornerRadius} L ${midX} ${endY + cornerRadius} Q ${midX} ${endY} ${midX - cornerRadius} ${endY} L ${endX} ${endY}`;
                        }
                    }
                } else {
                    // 垂直优先路径
                    if (dy > 0) {
                        // 向下
                        if (dx > 0) {
                            // 向右
                            return `M ${startX} ${startY} L ${startX} ${midY - cornerRadius} Q ${startX} ${midY} ${startX + cornerRadius} ${midY} L ${endX - cornerRadius} ${midY} Q ${endX} ${midY} ${endX} ${midY + cornerRadius} L ${endX} ${endY}`;
                        } else {
                            // 向左
                            return `M ${startX} ${startY} L ${startX} ${midY - cornerRadius} Q ${startX} ${midY} ${startX - cornerRadius} ${midY} L ${endX + cornerRadius} ${midY} Q ${endX} ${midY} ${endX} ${midY + cornerRadius} L ${endX} ${endY}`;
                        }
                    } else {
                        // 向上
                        if (dx > 0) {
                            // 向右
                            return `M ${startX} ${startY} L ${startX} ${midY + cornerRadius} Q ${startX} ${midY} ${startX + cornerRadius} ${midY} L ${endX - cornerRadius} ${midY} Q ${endX} ${midY} ${endX} ${midY - cornerRadius} L ${endX} ${endY}`;
                        } else {
                            // 向左
                            return `M ${startX} ${startY} L ${startX} ${midY + cornerRadius} Q ${startX} ${midY} ${startX - cornerRadius} ${midY} L ${endX + cornerRadius} ${midY} Q ${endX} ${midY} ${endX} ${midY - cornerRadius} L ${endX} ${endY}`;
                        }
                    }
                }
            }

            // 更新连线路径（用于元件移动时）
            function updateWirePath(wireElement, startX, startY, endX, endY) {
                if (wireElement.tagName === 'path') {
                    // 对于path元素，重新计算路径
                    const pathData = calculateBentPath(startX, startY, endX, endY);
                    wireElement.setAttribute('d', pathData);
                } else {
                    // 对于line元素（向后兼容）
                    wireElement.setAttribute('x1', startX);
                    wireElement.setAttribute('y1', startY);
                    wireElement.setAttribute('x2', endX);
                    wireElement.setAttribute('y2', endY);
                }
            }


            // 存储所有元件的状态
            const componentStates = new Map();
            // 存储锚点连接关系 - 每个锚点可以连接多个其他锚点
            const anchorConnections = new Map();
            // 当前选中的元素
            let selectedElement = null;

            // 时序逻辑支持
            const sequentialElements = new Map(); // 存储时序元件的状态和历史
            const clockEdgeDetection = new Map(); // 时钟边沿检测
            const updateQueue = []; // 时序更新队列

            // 元件SVG模板
            const componentSvgs = {
                'or-gate': `
                    <svg class="component-svg" viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
                        <path d="M50,30 Q120,30 150,60 Q120,90 50,90" fill="none" stroke="black" stroke-width="2"/>
                        <line x1="50" y1="30" x2="50" y2="90" stroke="black" stroke-width="2"/>
                        <text x="85" y="65" font-family="Arial" font-size="16">OR</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="45" r="5" fill="black"/>
                        <line x1="25" y1="45" x2="50" y2="45" stroke="black" stroke-width="2"/>
                        <text x="5" y="50" font-family="Arial" font-size="12">A</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="75" r="5" fill="black"/>
                        <line x1="25" y1="75" x2="50" y2="75" stroke="black" stroke-width="2"/>
                        <text x="5" y="80" font-family="Arial" font-size="12">B</text>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="60" r="5" fill="black"/>
                        <line x1="150" y1="60" x2="175" y2="60" stroke="black" stroke-width="2"/>
                        <text x="185" y="65" font-family="Arial" font-size="12">Y</text>
                    </svg>
                `,
                'input': `
                    <svg class="component-svg" viewBox="0 0 100 50" xmlns="http://www.w3.org/2000/svg">
                        <g id="input-group" transform="translate(50, 25)">
                            <rect id="input-bg" x="-40" y="-15" width="40" height="30" rx="5" fill="#006400" stroke="black" stroke-width="2" class="state-0"/>
                            <text id="input-text" class="state-text" x="-20" y="5" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="white">0</text>
                            <circle class="anchor output-anchor" data-anchor-type="output" cx="0" cy="0" r="5" fill="black"/>
                            <line x1="-5" y1="0" x2="0" y2="0" stroke="black" stroke-width="2"/>
                        </g>
                    </svg>
                `,
                'output': `
                    <svg class="component-svg" viewBox="-10 0 110 50" xmlns="http://www.w3.org/2000/svg">
                        <g id="output-group" transform="translate(50, 25)">
                            <rect id="output-bg" x="-40" y="-15" width="40" height="30" rx="5" fill="#008000" stroke="black" stroke-width="2" class="state-0"/>
                            <text id="output-text" class="state-text" x="-20" y="5" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="white">0</text>
                            <circle class="anchor input-anchor" data-anchor-type="input" cx="-50" cy="0" r="5" fill="black"/>
                            <line x1="-45" y1="0" x2="-40" y2="0" stroke="black" stroke-width="2"/>
                        </g>
                    </svg>
                `,
                'clock': `
                    <svg class="component-svg" viewBox="0 0 100 50" xmlns="http://www.w3.org/2000/svg">
                        <g id="clock-group" transform="translate(50, 25)">
                            <rect id="clock-bg" x="-40" y="-15" width="40" height="30" rx="5" fill="#FF6B35" stroke="black" stroke-width="2" class="clock-state"/>
                            <text id="clock-text" class="clock-text" x="-20" y="5" font-family="Arial" font-size="12" font-weight="bold" text-anchor="middle" fill="white">CLK</text>
                            <circle class="anchor output-anchor" data-anchor-type="output" cx="0" cy="0" r="5" fill="black"/>
                            <line x1="-5" y1="0" x2="0" y2="0" stroke="black" stroke-width="2"/>
                            <!-- 时钟波形图标 -->
                            <g transform="translate(-30, -8)">
                                <path d="M0,8 L0,0 L8,0 L8,8 L16,8 L16,0 L24,0 L24,8"
                                      fill="none" stroke="white" stroke-width="1.5"/>
                            </g>
                        </g>
                    </svg>
                `,
                'and-gate': `
                    <svg class="component-svg" viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
                        <path d="M50,30 L120,30 A30,30 0 0,1 120,90 L50,90 Z" fill="none" stroke="black" stroke-width="2"/>
                        <text x="85" y="65" font-family="Arial" font-size="16">AND</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="45" r="5" fill="black"/>
                        <line x1="25" y1="45" x2="50" y2="45" stroke="black" stroke-width="2"/>
                        <text x="5" y="50" font-family="Arial" font-size="12">A</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="75" r="5" fill="black"/>
                        <line x1="25" y1="75" x2="50" y2="75" stroke="black" stroke-width="2"/>
                        <text x="5" y="80" font-family="Arial" font-size="12">B</text>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="60" r="5" fill="black"/>
                        <line x1="150" y1="60" x2="175" y2="60" stroke="black" stroke-width="2"/>
                        <text x="185" y="65" font-family="Arial" font-size="12">Y</text>
                    </svg>
                `,
                'not-gate': `
                    <svg class="component-svg" viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
                        <path d="M50,30 L130,60 L50,90 Z" fill="none" stroke="black" stroke-width="2"/>
                        <circle cx="140" cy="60" r="8" fill="none" stroke="black" stroke-width="2"/>
                        <text x="85" y="65" font-family="Arial" font-size="16">NOT</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="60" r="5" fill="black"/>
                        <line x1="25" y1="60" x2="50" y2="60" stroke="black" stroke-width="2"/>
                        <text x="5" y="65" font-family="Arial" font-size="12">A</text>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="60" r="5" fill="black"/>
                        <line x1="148" y1="60" x2="175" y2="60" stroke="black" stroke-width="2"/>
                        <text x="185" y="65" font-family="Arial" font-size="12">Y</text>
                    </svg>
                `,
                'xor-gate': `
                    <svg class="component-svg" viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
                        <path d="M50,30 Q120,30 150,60 Q120,90 50,90" fill="none" stroke="black" stroke-width="2"/>
                        <path d="M40,30 Q110,30 140,60 Q110,90 40,90" fill="none" stroke="black" stroke-width="2"/>
                        <line x1="50" y1="30" x2="50" y2="90" stroke="black" stroke-width="2"/>
                        <text x="85" y="65" font-family="Arial" font-size="16">XOR</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="45" r="5" fill="black"/>
                        <line x1="25" y1="45" x2="50" y2="45" stroke="black" stroke-width="2"/>
                        <text x="5" y="50" font-family="Arial" font-size="12">A</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="75" r="5" fill="black"/>
                        <line x1="25" y1="75" x2="50" y2="75" stroke="black" stroke-width="2"/>
                        <text x="5" y="80" font-family="Arial" font-size="12">B</text>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="60" r="5" fill="black"/>
                        <line x1="150" y1="60" x2="175" y2="60" stroke="black" stroke-width="2"/>
                        <text x="185" y="65" font-family="Arial" font-size="12">Y</text>
                    </svg>
                `,
                'nand-gate': `
                    <svg class="component-svg" viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
                        <path d="M50,30 L120,30 A30,30 0 0,1 120,90 L50,90 Z" fill="none" stroke="black" stroke-width="2"/>
                        <circle cx="160" cy="60" r="8" fill="none" stroke="black" stroke-width="2"/>
                        <text x="85" y="65" font-family="Arial" font-size="16">NAND</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="45" r="5" fill="black"/>
                        <line x1="25" y1="45" x2="50" y2="45" stroke="black" stroke-width="2"/>
                        <text x="5" y="50" font-family="Arial" font-size="12">A</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="75" r="5" fill="black"/>
                        <line x1="25" y1="75" x2="50" y2="75" stroke="black" stroke-width="2"/>
                        <text x="5" y="80" font-family="Arial" font-size="12">B</text>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="60" r="5" fill="black"/>
                        <line x1="168" y1="60" x2="175" y2="60" stroke="black" stroke-width="2"/>
                        <text x="185" y="65" font-family="Arial" font-size="12">Y</text>
                    </svg>
                `,
                'd-flipflop': `
                    <svg class="component-svg" viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="20" width="100" height="80" fill="none" stroke="black" stroke-width="2"/>
                        <text x="100" y="45" font-family="Arial" font-size="16" text-anchor="middle">D</text>
                        <text x="100" y="85" font-family="Arial" font-size="16" text-anchor="middle">FF</text>

                        <!-- D输入 -->
                        <text x="5" y="45" font-family="Arial" font-size="12">D</text>
                        <line x1="25" y1="40" x2="50" y2="40" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="40" r="5" fill="black"/>

                        <!-- 时钟输入 -->
                        <text x="5" y="85" font-family="Arial" font-size="12">CLK</text>
                        <line x1="25" y1="80" x2="50" y2="80" stroke="black" stroke-width="2"/>
                        <path d="M45,75 L50,80 L45,85" fill="none" stroke="black" stroke-width="1"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="80" r="5" fill="black"/>

                        <!-- Q输出 -->
                        <text x="185" y="55" font-family="Arial" font-size="12">Q</text>
                        <line x1="150" y1="50" x2="175" y2="50" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="50" r="5" fill="black"/>

                        <!-- 非Q输出 -->
                        <text x="185" y="75" font-family="Arial" font-size="12">Q̄</text>
                        <line x1="150" y1="70" x2="175" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="70" r="5" fill="black"/>
                    </svg>
                    `,
                'd-flipflop': `
                    <svg class="component-svg" viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="20" width="100" height="80" fill="#f0f0f0" stroke="black" stroke-width="2"/>
                        <text x="100" y="45" font-family="Arial" font-size="16" text-anchor="middle">D</text>
                        <text x="100" y="85" font-family="Arial" font-size="16" text-anchor="middle">FF</text>

                        <!-- D输入 -->
                        <text x="5" y="45" font-family="Arial" font-size="12">D</text>
                        <line x1="25" y1="40" x2="50" y2="40" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="40" r="5" fill="black"/>

                        <!-- 时钟输入 -->
                        <text x="5" y="85" font-family="Arial" font-size="12">CLK</text>
                        <line x1="25" y1="80" x2="50" y2="80" stroke="black" stroke-width="2"/>
                        <path d="M45,75 L50,80 L45,85" fill="none" stroke="black" stroke-width="1"/>
                        <circle class="anchor input-anchor clock-input" data-anchor-type="clock" cx="20" cy="80" r="5" fill="#0066cc"/>

                        <!-- Q输出 -->
                        <text x="185" y="55" font-family="Arial" font-size="12">Q</text>
                        <line x1="150" y1="50" x2="175" y2="50" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="50" r="5" fill="black"/>

                        <!-- 非Q输出 -->
                        <text x="185" y="75" font-family="Arial" font-size="12">Q̄</text>
                        <line x1="150" y1="70" x2="175" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="70" r="5" fill="black"/>
                    </svg>
                `,
                'adder': `
                    <svg class="component-svg" viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="20" width="100" height="80" fill="#e8f4fd" stroke="black" stroke-width="2"/>
                        <text x="100" y="45" font-family="Arial" font-size="14" text-anchor="middle">ADD</text>
                        <text x="100" y="85" font-family="Arial" font-size="12" text-anchor="middle">加法器</text>

                        <!-- A输入 -->
                        <text x="5" y="45" font-family="Arial" font-size="12">A</text>
                        <line x1="25" y1="40" x2="50" y2="40" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="40" r="5" fill="black"/>

                        <!-- B输入 -->
                        <text x="5" y="65" font-family="Arial" font-size="12">B</text>
                        <line x1="25" y1="60" x2="50" y2="60" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="60" r="5" fill="black"/>

                        <!-- 进位输入 -->
                        <text x="5" y="85" font-family="Arial" font-size="12">Cin</text>
                        <line x1="25" y1="80" x2="50" y2="80" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="80" r="5" fill="black"/>

                        <!-- 和输出 -->
                        <text x="185" y="55" font-family="Arial" font-size="12">S</text>
                        <line x1="150" y1="50" x2="175" y2="50" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="50" r="5" fill="black"/>

                        <!-- 进位输出 -->
                        <text x="185" y="75" font-family="Arial" font-size="12">Cout</text>
                        <line x1="150" y1="70" x2="175" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="70" r="5" fill="black"/>
                    </svg>
                `,
                'subtractor': `
                    <svg class="component-svg" viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="20" width="100" height="80" fill="#fde8e8" stroke="black" stroke-width="2"/>
                        <text x="100" y="45" font-family="Arial" font-size="14" text-anchor="middle">SUB</text>
                        <text x="100" y="85" font-family="Arial" font-size="12" text-anchor="middle">减法器</text>

                        <!-- A输入 -->
                        <text x="5" y="45" font-family="Arial" font-size="12">A</text>
                        <line x1="25" y1="40" x2="50" y2="40" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="40" r="5" fill="black"/>

                        <!-- B输入 -->
                        <text x="5" y="65" font-family="Arial" font-size="12">B</text>
                        <line x1="25" y1="60" x2="50" y2="60" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="60" r="5" fill="black"/>

                        <!-- 借位输入 -->
                        <text x="5" y="85" font-family="Arial" font-size="12">Bin</text>
                        <line x1="25" y1="80" x2="50" y2="80" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="80" r="5" fill="black"/>

                        <!-- 差输出 -->
                        <text x="185" y="55" font-family="Arial" font-size="12">D</text>
                        <line x1="150" y1="50" x2="175" y2="50" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="50" r="5" fill="black"/>

                        <!-- 借位输出 -->
                        <text x="185" y="75" font-family="Arial" font-size="12">Bout</text>
                        <line x1="150" y1="70" x2="175" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="70" r="5" fill="black"/>
                    </svg>
                `,
                'divider': `
                    <svg class="component-svg" viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="20" width="100" height="80" fill="#f0e8fd" stroke="black" stroke-width="2"/>
                        <text x="100" y="45" font-family="Arial" font-size="14" text-anchor="middle">DIV</text>
                        <text x="100" y="85" font-family="Arial" font-size="12" text-anchor="middle">除法器</text>

                        <!-- 被除数输入 -->
                        <text x="5" y="45" font-family="Arial" font-size="12">A</text>
                        <line x1="25" y1="40" x2="50" y2="40" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="40" r="5" fill="black"/>

                        <!-- 除数输入 -->
                        <text x="5" y="75" font-family="Arial" font-size="12">B</text>
                        <line x1="25" y1="70" x2="50" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="70" r="5" fill="black"/>

                        <!-- 商输出 -->
                        <text x="185" y="55" font-family="Arial" font-size="12">Q</text>
                        <line x1="150" y1="50" x2="175" y2="50" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="50" r="5" fill="black"/>

                        <!-- 余数输出 -->
                        <text x="185" y="75" font-family="Arial" font-size="12">R</text>
                        <line x1="150" y1="70" x2="175" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="70" r="5" fill="black"/>
                    </svg>
                `,
                'complement': `
                    <svg class="component-svg" viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="30" width="100" height="60" fill="#e8fde8" stroke="black" stroke-width="2"/>
                        <text x="100" y="55" font-family="Arial" font-size="14" text-anchor="middle">COMP</text>
                        <text x="100" y="75" font-family="Arial" font-size="12" text-anchor="middle">求补器</text>

                        <!-- 输入 -->
                        <text x="5" y="65" font-family="Arial" font-size="12">A</text>
                        <line x1="25" y1="60" x2="50" y2="60" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="60" r="5" fill="black"/>

                        <!-- 输出 -->
                        <text x="185" y="65" font-family="Arial" font-size="12">Ā</text>
                        <line x1="150" y1="60" x2="175" y2="60" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="60" r="5" fill="black"/>
                    </svg>
                `
            };

            // 逻辑门计算函数
            const logicFunctions = {
                'and-gate': (inputs) => inputs.reduce((a, b) => a && b, true),
                'or-gate': (inputs) => inputs.reduce((a, b) => a || b, false),
                'not-gate': (inputs) => !inputs[0],
                'xor-gate': (inputs) => inputs[0] !== inputs[1],
                'nand-gate': (inputs) => !inputs.reduce((a, b) => a && b, true),
                'd-flipflop': (inputs) => {
                    // D触发器的逻辑由时钟边沿触发处理，这里返回当前状态
                    // 实际的状态更新在 processDFlipFlop 中处理
                    return inputs[0] || 0; // 返回D输入状态作为默认
                },
                'adder': (inputs) => {
                    // 全加器逻辑: A + B + Cin
                    const a = inputs[0] || 0;
                    const b = inputs[1] || 0;
                    const cin = inputs[2] || 0;
                    const sum = a + b + cin;
                    return {
                        sum: sum % 2,      // 和输出 (S)
                        carry: Math.floor(sum / 2)  // 进位输出 (Cout)
                    };
                },
                'subtractor': (inputs) => {
                    // 全减器逻辑: A - B - Bin
                    const a = inputs[0] || 0;
                    const b = inputs[1] || 0;
                    const bin = inputs[2] || 0;
                    const diff = a - b - bin;
                    return {
                        difference: diff >= 0 ? diff : (diff + 2),  // 差输出 (D)
                        borrow: diff < 0 ? 1 : 0  // 借位输出 (Bout)
                    };
                },
                'divider': (inputs) => {
                    // 除法器逻辑: A / B
                    const a = inputs[0] || 0;
                    const b = inputs[1] || 0; // 不设置默认值，保持原始输入
                    if (b === 0) {
                        return { quotient: 0, remainder: 0 }; // 除零保护
                    }
                    return {
                        quotient: Math.floor(a / b),  // 商输出 (Q)
                        remainder: a % b  // 余数输出 (R)
                    };
                },
                'complement': (inputs) => {
                    // 求补器逻辑: ~A (按位取反)
                    const a = inputs[0] || 0;
                    return 1 - a; // 对于单位逻辑，取反就是1-a
                }
            };

            // 初始化外部组件
            if (typeof initializePushButtonComponent === 'function') {
                initializePushButtonComponent(componentSvgs, logicFunctions);
            }
            if (typeof initializeSwitchComponent === 'function') {
                initializeSwitchComponent(componentSvgs, logicFunctions);
            }

            // 快捷工具栏事件处理
            toolbarItems.forEach(item => {
                item.addEventListener('click', function() {
                    const tool = this.getAttribute('data-tool');

                    // 移除所有active状态
                    toolbarItems.forEach(t => t.classList.remove('active'));

                    if (tool === 'text') {
                        // 文字工具逻辑
                        this.classList.add('active');
                        currentTool = 'text';
                        canvas.style.cursor = 'text';
                        console.log('文字工具已激活 - 点击画布添加文字');
                    } else if (['input', 'output', 'and-gate', 'or-gate', 'not-gate', 'adder', 'subtractor', 'divider', 'complement', 'push-button', 'switch'].includes(tool)) {
                        // 元件工具
                        this.classList.add('active');
                        currentTool = tool;
                        canvas.style.cursor = 'crosshair';

                        // 创建元件
                        createComponentFromToolbar(tool);
                    }
                });
            });

            // 从快捷栏创建元件的函数
            function createComponentFromToolbar(type) {
                if (!componentSvgs[type]) return;

                // 创建元件容器
                const componentDiv = document.createElement('div');
                componentDiv.className = 'component';
                componentDiv.style.left = '150px';  // 在画布中央位置
                componentDiv.style.top = '150px';
                componentDiv.innerHTML = componentSvgs[type];
                componentDiv.dataset.type = type;
                componentDiv.dataset.id = Date.now(); // 唯一ID
                canvas.appendChild(componentDiv);

                // 初始化状态（复用原有逻辑）
                initializeComponent(componentDiv, type);

                // 重置工具状态
                toolbarItems.forEach(t => t.classList.remove('active'));
                currentTool = null;
                canvas.style.cursor = 'default';
            }

            // 提取元件初始化逻辑为独立函数
            function initializeComponent(componentDiv, type) {
                // 初始化状态
                if (type === 'input' || type === 'output') {
                    componentStates.set(componentDiv.dataset.id, 0);
                } else if (type === 'clock') {
                    const id = componentDiv.dataset.id;
                    componentStates.set(id, 0);
                    clockPreviousStates.set(id, 0);
                    startClockSignal(componentDiv);
                } else if (type === 'd-flipflop') {
                    const id = componentDiv.dataset.id;
                    componentStates.set(id, 0);
                    sequentialElements.set(id, {
                        q: 0,
                        qBar: 1,
                        lastD: 0,
                        lastClock: 0
                    });
                    updateDFlipFlopDisplay(componentDiv, 0, 1);
                } else if (type === 'push-button') {
                    const id = componentDiv.dataset.id;
                    componentStates.set(id, 0);
                    // 设置默认配置为高电平触发
                    if (typeof setButtonConfig === 'function') {
                        setButtonConfig(id, { trigger: 'high' });
                    }
                } else if (type === 'switch') {
                    const id = componentDiv.dataset.id;
                    componentStates.set(id, 0);
                    // 初始化开关状态
                    if (typeof setSwitchState === 'function') {
                        setSwitchState(id, 0);
                    }
                }

                // 设置组件样式和提示
                if (type === 'output') {
                    componentDiv.style.cursor = 'default';
                    componentDiv.title = '输出端口 - 只能接收信号，不能手动切换';
                } else {
                    componentDiv.style.cursor = 'grab';
                }

                // 添加所有必要的事件监听器
                addComponentEventListeners(componentDiv, type);
            }

            // 添加元件事件监听器的函数
            function addComponentEventListeners(componentDiv, type) {
                // 添加拖动功能
                    let isDragging = false;
                    let offsetX, offsetY;
                    let scale = 1;
                    let transform = '';

                    // 记录元件对应的连线，用于更新
                    const updateWires = () => {
                        const updatedWires = new Set();

                        // 递归更新连线的函数
                        const updateWireRecursively = (wire) => {
                            if (updatedWires.has(wire)) return; // 避免重复更新

                            updatedWires.add(wire);
                            updateWirePosition(wire);

                            // 查找以此连线为分支源的所有分支连线
                            const branchWires = wires.filter(w => w.branchFrom === wire.line);
                            branchWires.forEach(branchWire => {
                                updateWireRecursively(branchWire);
                            });
                        };

                        wires.forEach(wire => {
                            let shouldUpdate = false;

                            // 检查普通连线（两端都是锚点）
                            if (wire.start && wire.start.closest('.component') === componentDiv) {
                                shouldUpdate = true;
                            }
                            if (wire.end && wire.end.closest('.component') === componentDiv) {
                                shouldUpdate = true;
                            }

                            // 检查分支连线（从连线分支到锚点）
                            if (wire.branchFrom && wire.end && wire.end.closest('.component') === componentDiv) {
                                shouldUpdate = true;
                            }

                            // 检查连接到连线的情况（从锚点连接到连线）
                            if (wire.connectsTo && wire.start && wire.start.closest('.component') === componentDiv) {
                                shouldUpdate = true;
                            }

                            // 检查作为目标连线的情况（其他连线连接到这条连线）
                            if (wire.start && wire.end) {
                                const connectingWires = wires.filter(w => w.connectsTo === wire.line);
                                if (connectingWires.length > 0) {
                                    connectingWires.forEach(connectingWire => {
                                        updateWireRecursively(connectingWire);
                                    });
                                }
                            }

                            if (shouldUpdate) {
                                updateWireRecursively(wire);
                            }
                        });
                    };

                    componentDiv.addEventListener('mousedown', function (e) {
                        // 防止拖动锚点时触发元件拖动
                        if (e.target.classList.contains('anchor')) return;

                        // 在连线模式下，不允许拖拽组件
                        if (gestureControl && gestureControl.isConnectMode()) {
                            return;
                        }

                        // 选择元件
                        selectElement(componentDiv);

                        isDragging = true;
                        offsetX = e.clientX - componentDiv.getBoundingClientRect().left;
                        offsetY = e.clientY - componentDiv.getBoundingClientRect().top;
                        if (type !== 'output') {
                            componentDiv.style.cursor = 'grabbing';
                        }
                        componentDiv.style.zIndex = '20'; // 拖动时置于顶层
                    });

                    // 添加右键菜单
                    componentDiv.addEventListener('contextmenu', function (e) {
                        e.preventDefault();
                        selectElement(componentDiv);
                        showContextMenu(e.clientX, e.clientY);
                    });

                    document.addEventListener('mousemove', function (e) {
                        if (!isDragging) return;

                        const canvasRect = canvas.getBoundingClientRect();
                        const componentRect = componentDiv.getBoundingClientRect();

                        let newLeft = e.clientX - offsetX;
                        let newTop = e.clientY - offsetY;

                        // 限制在画布内
                        newLeft = Math.max(canvasRect.left, Math.min(newLeft, canvasRect.right - componentRect.width));
                        newTop = Math.max(canvasRect.top, Math.min(newTop, canvasRect.bottom - componentRect.height));

                        // 应用网格磁吸功能
                        const snapResult = magneticSnap.snapComponentToGrid(componentDiv, newLeft, newTop, canvas);

                        componentDiv.style.left = snapResult.left + 'px';
                        componentDiv.style.top = snapResult.top + 'px';

                        // 更新连线
                        updateWires();
                    });

                    document.addEventListener('mouseup', function () {
                        if (isDragging) {
                            isDragging = false;
                            if (type === 'output') {
                                componentDiv.style.cursor = 'default';
                            } else {
                                componentDiv.style.cursor = 'grab';
                            }
                            componentDiv.style.zIndex = '10'; // 恢复默认层级

                            // 隐藏磁吸指示器
                            magneticSnap.hideAllIndicators();
                        }
                    });

                    // 添加缩放功能
                    componentDiv.addEventListener('wheel', function (e) {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? 0.9 : 1.1;
                        scale *= delta;
                        scale = Math.max(0.5, Math.min(scale, 2));

                        const svg = componentDiv.querySelector('svg');
                        const rotation = parseInt(componentDiv.dataset.rotation) || 0;
                        svg.style.transform = `rotate(${rotation}deg) scale(${scale})`;
                        componentDiv.dataset.scale = scale;

                        // 更新连线
                        updateWires();
                    });

                    // 为按钮添加特殊的事件处理
                    if (type === 'push-button') {
                        const buttonGroup = componentDiv.querySelector('#push-button-group') || componentDiv;

                        // 按下事件
                        buttonGroup.addEventListener('mousedown', function(e) {
                            if (e.target.classList.contains('anchor')) return;
                            e.preventDefault();

                            const id = componentDiv.dataset.id;
                            const config = typeof getButtonConfig === 'function' ? getButtonConfig(id) : { trigger: 'high' };

                            // 更新视觉状态
                            if (typeof updatePushButtonDisplay === 'function') {
                                updatePushButtonDisplay(componentDiv, 1);
                            }

                            // 根据触发模式处理输出
                            switch(config.trigger) {
                                case 'rising':
                                    // 上升沿：按下瞬间输出1，然后立即回到0
                                    componentStates.set(id, 1);
                                    propagateSignal(componentDiv);
                                    setTimeout(() => {
                                        componentStates.set(id, 0);
                                        propagateSignal(componentDiv);
                                    }, 50);
                                    break;
                                case 'high':
                                    // 高电平：按下时持续输出1
                                    componentStates.set(id, 1);
                                    propagateSignal(componentDiv);
                                    break;
                                case 'low':
                                    // 低电平：按下时输出0
                                    componentStates.set(id, 0);
                                    propagateSignal(componentDiv);
                                    break;
                            }
                        });

                        // 松开事件
                        document.addEventListener('mouseup', function(e) {
                            if (!componentDiv.contains(e.target) && e.target !== componentDiv) return;

                            const id = componentDiv.dataset.id;
                            const config = typeof getButtonConfig === 'function' ? getButtonConfig(id) : { trigger: 'high' };

                            // 更新视觉状态
                            if (typeof updatePushButtonDisplay === 'function') {
                                updatePushButtonDisplay(componentDiv, 0);
                            }

                            // 根据触发模式处理输出
                            switch(config.trigger) {
                                case 'falling':
                                    // 下降沿：释放瞬间输出1，然后立即回到0
                                    componentStates.set(id, 1);
                                    propagateSignal(componentDiv);
                                    setTimeout(() => {
                                        componentStates.set(id, 0);
                                        propagateSignal(componentDiv);
                                    }, 50);
                                    break;
                                case 'high':
                                    // 高电平：释放时回到0
                                    componentStates.set(id, 0);
                                    propagateSignal(componentDiv);
                                    break;
                                case 'low':
                                    // 低电平：释放时回到1
                                    componentStates.set(id, 1);
                                    propagateSignal(componentDiv);
                                    break;
                            }
                        });
                    }

                    // 为开关添加点击切换状态功能
                    if (type === 'switch') {
                        const switchGroup = componentDiv.querySelector('#switch-group') || componentDiv;
                        switchGroup.addEventListener('click', function(e) {
                            // 避免锚点点击触发状态切换
                            if (e.target.classList.contains('anchor')) return;

                            const id = componentDiv.dataset.id;

                            // 获取当前状态并切换
                            const currentState = componentStates.get(id) || 0;
                            const newState = currentState === 0 ? 1 : 0;

                            // 更新状态
                            componentStates.set(id, newState);

                            // 更新视觉状态
                            if (typeof updateSwitchDisplay === 'function') {
                                updateSwitchDisplay(componentDiv, newState);
                            }

                            console.log(`Switch (ID: ${id}) 状态切换为: ${newState}`);
                            console.log(`componentStates.get(${id}):`, componentStates.get(id));

                            // 传播信号
                            propagateSignal(componentDiv);
                        });
                    }

                    // 为输入/输出端口和时钟信号添加点击切换状态功能
                    if (type === 'input' || type === 'output' || type === 'clock') {
                        const group = componentDiv.querySelector('#input-group') ||
                                     componentDiv.querySelector('#output-group') ||
                                     componentDiv.querySelector('#clock-group') ||
                                     componentDiv;
                        group.addEventListener('click', function(e) {
                            // 避免锚点点击触发状态切换
                            if (e.target.classList.contains('anchor')) return;

                            // 输出端口不允许手动点击切换状态，只能接收信号
                            if (type === 'output') {
                                return;
                            }

                            const id = componentDiv.dataset.id;
                            const currentState = componentStates.get(id);
                            const newState = currentState === 0 ? 1 : 0;
                            componentStates.set(id, newState);

                            // 更新显示
                            if (type === 'clock') {
                                const bgElement = componentDiv.querySelector('#clock-bg');
                                if (bgElement) {
                                    bgElement.classList.toggle('clock-active');
                                }
                            } else {
                                const textElement = componentDiv.querySelector('.state-text');
                                const bgElement = componentDiv.querySelector('#input-bg') || componentDiv.querySelector('#output-bg');

                                if (textElement) textElement.textContent = newState;
                                if (bgElement) {
                                    bgElement.classList.remove(currentState === 0 ? 'state-0' : 'state-1');
                                    bgElement.classList.add(newState === 0 ? 'state-0' : 'state-1');
                                }
                            }

                            console.log(`${type} (ID: ${id}) 状态已切换为: ${newState}`);

                            // 触发逻辑计算
                            propagateSignal(componentDiv);
                        });
                    }
                }

            // 点击元件列表项添加元件到画布
            componentItems.forEach(item => {
                item.addEventListener('click', function () {
                    const type = this.getAttribute('data-type');
                    if (!componentSvgs[type]) return;

                    // 创建元件容器
                    const componentDiv = document.createElement('div');
                    componentDiv.className = 'component';
                    componentDiv.style.left = '100px';
                    componentDiv.style.top = '100px';
                    componentDiv.innerHTML = componentSvgs[type];
                    componentDiv.dataset.type = type;
                    componentDiv.dataset.id = Date.now(); // 唯一ID
                    canvas.appendChild(componentDiv);

                    // 使用统一的初始化函数
                    initializeComponent(componentDiv, type);
                });
            });

            // 锚点和连线拖拽连线功能
            let isDraggingWire = false;
            let dragStartAnchor = null;
            let dragStartWire = null;
            let dragStartPoint = null;
            let tempWire = null;

            // 锚点和连线鼠标按下事件
            canvas.addEventListener('mousedown', function (e) {
                if (e.target.classList.contains('anchor')) {
                    console.log('锚点点击，开始连线');
                    e.preventDefault();
                    e.stopPropagation();

                    isDraggingWire = true;
                    dragStartAnchor = e.target;

                    // 高亮起始锚点
                    dragStartAnchor.setAttribute('r', '8');

                    // 获取起始锚点坐标
                    const startRect = dragStartAnchor.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();
                    const startX = startRect.left - canvasRect.left + startRect.width / 2;
                    const startY = startRect.top - canvasRect.top + startRect.height / 2;

                    // 设置拖拽起始点
                    dragStartPoint = { x: startX, y: startY };

                    // 创建临时连线（使用path支持转弯）
                    tempWire = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    tempWire.setAttribute('class', 'wire');
                    tempWire.setAttribute('fill', 'none');
                    tempWire.setAttribute('stroke', '#ff0000'); // 红色临时线
                    tempWire.setAttribute('stroke-dasharray', '5,5'); // 虚线
                    tempWire.setAttribute('stroke-width', '3'); // 增加线宽便于观察
                    tempWire.setAttribute('d', `M ${startX} ${startY} L ${startX + 1} ${startY + 1}`);
                    wireLayer.appendChild(tempWire);

                } else if (e.target.classList.contains('wire')) {
                    e.preventDefault();
                    e.stopPropagation();

                    isDraggingWire = true;
                    dragStartWire = e.target;

                    // 获取鼠标在连线上的点击位置
                    const canvasRect = canvas.getBoundingClientRect();
                    const clickX = e.clientX - canvasRect.left;
                    const clickY = e.clientY - canvasRect.top;

                    dragStartPoint = { x: clickX, y: clickY };

                    // 高亮起始连线
                    dragStartWire.setAttribute('stroke', '#0066cc');
                    dragStartWire.setAttribute('stroke-width', '4');

                    // 创建临时连线（使用path支持转弯）
                    tempWire = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    tempWire.setAttribute('class', 'wire');
                    tempWire.setAttribute('fill', 'none');
                    tempWire.setAttribute('stroke', '#ff0000'); // 红色临时线
                    tempWire.setAttribute('stroke-dasharray', '5,5'); // 虚线
                    tempWire.setAttribute('stroke-width', '3'); // 增加线宽便于观察
                    tempWire.setAttribute('d', `M ${clickX} ${clickY} L ${clickX + 1} ${clickY + 1}`);
                    wireLayer.appendChild(tempWire);



                }
            });

            // 鼠标移动事件 - 更新临时连线
            document.addEventListener('mousemove', function (e) {
                if (isDraggingWire && tempWire && dragStartPoint) {
                    const canvasRect = canvas.getBoundingClientRect();
                    let mouseX = e.clientX - canvasRect.left;
                    let mouseY = e.clientY - canvasRect.top;

                    // 应用锚点磁吸功能，排除起始锚点
                    const snapResult = magneticSnap.snapToAnchor(e.clientX, e.clientY, canvas,
                        dragStartAnchor ? dragStartAnchor.closest('.component') : null,
                        dragStartAnchor);

                    if (snapResult.snapped) {
                        mouseX = snapResult.relativeX;
                        mouseY = snapResult.relativeY;

                        // 当磁吸到锚点时，让连线端点更明显地指向目标
                        tempWire.setAttribute('stroke', '#FF9800');
                        tempWire.setAttribute('stroke-width', '3');
                    } else {
                        // 恢复正常连线样式
                        tempWire.setAttribute('stroke', '#666');
                        tempWire.setAttribute('stroke-width', '2');
                    }

                    // 更新临时连线路径，支持转弯
                    const startX = dragStartPoint.x;
                    const startY = dragStartPoint.y;
                    const pathData = calculateBentPath(startX, startY, mouseX, mouseY);
                    tempWire.setAttribute('d', pathData);
                }
            });

            // 鼠标释放事件 - 完成连线或取消
            document.addEventListener('mouseup', function (e) {
                if (isDraggingWire) {
                    // 使用磁吸功能检测最近的锚点，而不是依赖精确点击
                    const snapResult = magneticSnap.snapToAnchor(e.clientX, e.clientY, canvas,
                        dragStartAnchor ? dragStartAnchor.closest('.component') : null,
                        dragStartAnchor);

                    const targetAnchor = snapResult.snapped ? snapResult.anchor :
                        (e.target.classList.contains('anchor') ? e.target : null);
                    const targetWire = e.target.classList.contains('wire') ? e.target : null;

                    if (targetAnchor) {
                        // 释放在锚点上
                        let canCreateConnection = false;
                        let startX, startY, endX, endY;

                        if (dragStartAnchor) {
                            // 从锚点开始的拖拽
                            if (targetAnchor !== dragStartAnchor) {
                                // 允许所有锚点之间的连接，包括同一元件的锚点
                                canCreateConnection = true;
                                const startRect = dragStartAnchor.getBoundingClientRect();
                                const endRect = targetAnchor.getBoundingClientRect();
                                const canvasRect = canvas.getBoundingClientRect();

                                startX = startRect.left - canvasRect.left + startRect.width / 2;
                                startY = startRect.top - canvasRect.top + startRect.height / 2;
                                endX = endRect.left - canvasRect.left + endRect.width / 2;
                                endY = endRect.top - canvasRect.top + endRect.height / 2;
                            }
                        } else if (dragStartWire && dragStartPoint) {
                            // 从连线开始的拖拽
                            // 允许连接到所有类型的锚点
                            canCreateConnection = true;
                            const endRect = targetAnchor.getBoundingClientRect();
                            const canvasRect = canvas.getBoundingClientRect();

                            startX = dragStartPoint.x;
                            startY = dragStartPoint.y;
                            endX = endRect.left - canvasRect.left + endRect.width / 2;
                            endY = endRect.top - canvasRect.top + endRect.height / 2;
                        }

                        if (canCreateConnection) {
                            // 创建带转弯的连线
                            const wirePath = createBentWire(startX, startY, endX, endY);
                            wireLayer.appendChild(wirePath);

                            // 为连线添加右键菜单
                            wirePath.addEventListener('contextmenu', function (e) {
                                e.preventDefault();
                                selectElement(wirePath);
                                showContextMenu(e.clientX, e.clientY);
                            });

                            // 为连线添加点击选择功能
                            wirePath.addEventListener('click', function (e) {
                                if (!isDraggingWire) {
                                    selectElement(wirePath);
                                }
                            });

                            if (dragStartAnchor) {
                                // 从锚点开始的连线，存储锚点关联
                                wires.push({
                                    line: wirePath,
                                    start: dragStartAnchor,
                                    end: targetAnchor
                                });

                                // 支持多连接：为每个锚点维护一个连接数组
                                if (!anchorConnections.has(dragStartAnchor)) {
                                    anchorConnections.set(dragStartAnchor, []);
                                }
                                if (!anchorConnections.has(targetAnchor)) {
                                    anchorConnections.set(targetAnchor, []);
                                }

                                // 添加双向连接，避免重复
                                const startConnections = anchorConnections.get(dragStartAnchor);
                                const targetConnections = anchorConnections.get(targetAnchor);

                                if (!startConnections.includes(targetAnchor)) {
                                    startConnections.push(targetAnchor);
                                }
                                if (!targetConnections.includes(dragStartAnchor)) {
                                    targetConnections.push(dragStartAnchor);
                                }

                                // 触发逻辑计算
                                propagateSignal(dragStartAnchor.closest('.component') || targetAnchor.closest('.component'));
                            } else if (dragStartWire) {
                                // 从连线开始的连线，创建分支连接
                                const originalWire = wires.find(w => w.line === dragStartWire);
                                let branchRatio = 0.5; // 默认中点

                                // 计算分支点在原连线上的比例
                                if (originalWire && originalWire.start && originalWire.end) {
                                    const startRect = originalWire.start.getBoundingClientRect();
                                    const endRect = originalWire.end.getBoundingClientRect();
                                    const canvasRect = canvas.getBoundingClientRect();

                                    const startX = startRect.left - canvasRect.left + startRect.width / 2;
                                    const startY = startRect.top - canvasRect.top + startRect.height / 2;
                                    const endX = endRect.left - canvasRect.left + endRect.width / 2;
                                    const endY = endRect.top - canvasRect.top + endRect.height / 2;

                                    const totalLength = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                                    const branchLength = Math.sqrt(Math.pow(dragStartPoint.x - startX, 2) + Math.pow(dragStartPoint.y - startY, 2));

                                    branchRatio = totalLength > 0 ? branchLength / totalLength : 0.5;
                                }

                                wires.push({
                                    line: wirePath,
                                    start: null, // 从连线分支，没有起始锚点
                                    end: targetAnchor,
                                    branchFrom: dragStartWire,
                                    branchPoint: dragStartPoint,
                                    branchRatio: branchRatio
                                });

                                // 找到原连线对应的信号源并传播到新的目标锚点
                                if (originalWire && originalWire.start) {
                                    propagateSignal(originalWire.start.closest('.component'));
                                }
                            }
                        }
                    } else if (targetWire && dragStartAnchor) {
                        // 释放在连线上（从锚点拖拽到连线）
                        const canvasRect = canvas.getBoundingClientRect();
                        const releaseX = e.clientX - canvasRect.left;
                        const releaseY = e.clientY - canvasRect.top;

                        // 允许连接到所有连线，包括相关的连线
                        {
                            // 创建从锚点到连线的分支连接
                            const startRect = dragStartAnchor.getBoundingClientRect();
                            const startX = startRect.left - canvasRect.left + startRect.width / 2;
                            const startY = startRect.top - canvasRect.top + startRect.height / 2;

                            // 创建带转弯的连线
                            const line = createBentWire(startX, startY, releaseX, releaseY);
                            wireLayer.appendChild(line);

                            // 为连线添加右键菜单和点击选择功能
                            line.addEventListener('contextmenu', function (e) {
                                e.preventDefault();
                                selectElement(line);
                                showContextMenu(e.clientX, e.clientY);
                            });

                            line.addEventListener('click', function (e) {
                                if (!isDraggingWire) {
                                    selectElement(line);
                                }
                            });

                            // 计算连接点在目标连线上的比例
                            const targetWireData = wires.find(w => w.line === targetWire);
                            let connectionRatio = 0.5; // 默认中点

                            if (targetWireData && targetWireData.start && targetWireData.end) {
                                const targetStartRect = targetWireData.start.getBoundingClientRect();
                                const targetEndRect = targetWireData.end.getBoundingClientRect();

                                const targetStartX = targetStartRect.left - canvasRect.left + targetStartRect.width / 2;
                                const targetStartY = targetStartRect.top - canvasRect.top + targetStartRect.height / 2;
                                const targetEndX = targetEndRect.left - canvasRect.left + targetEndRect.width / 2;
                                const targetEndY = targetEndRect.top - canvasRect.top + targetEndRect.height / 2;

                                const totalLength = Math.sqrt(Math.pow(targetEndX - targetStartX, 2) + Math.pow(targetEndY - targetStartY, 2));
                                const connectionLength = Math.sqrt(Math.pow(releaseX - targetStartX, 2) + Math.pow(releaseY - targetStartY, 2));

                                connectionRatio = totalLength > 0 ? connectionLength / totalLength : 0.5;
                            }

                            // 存储连线信息（反向分支：从锚点到连线）
                            wires.push({
                                line: line,
                                start: dragStartAnchor,
                                end: null, // 连接到连线，没有终点锚点
                                connectsTo: targetWire,
                                connectionPoint: { x: releaseX, y: releaseY },
                                connectionRatio: connectionRatio
                            });

                            console.log("创建了从锚点到连线的连接");

                            // 传播信号
                            propagateSignal(dragStartAnchor.closest('.component'));
                        }
                    }

                    // 清理
                    if (tempWire) {
                        wireLayer.removeChild(tempWire);
                        tempWire = null;
                    }

                    // 恢复起始锚点状态
                    if (dragStartAnchor) {
                        dragStartAnchor.setAttribute('r', '5');
                        dragStartAnchor = null;
                    }

                    // 恢复起始连线状态
                    if (dragStartWire) {
                        dragStartWire.setAttribute('stroke', '#000');
                        dragStartWire.setAttribute('stroke-width', '2');
                        dragStartWire = null;
                    }

                    dragStartPoint = null;
                    isDraggingWire = false;

                    // 隐藏磁吸指示器
                    magneticSnap.hideAllIndicators();
                }
            });

            // 更新连线位置的函数
            function updateWirePosition(wire) {
                if (wire.branchFrom && wire.branchPoint) {
                    // 分支连线：需要更新分支点位置和终点位置
                    const originalWire = wires.find(w => w.line === wire.branchFrom);
                    if (originalWire) {
                        // 更新分支点位置
                        const updatedBranchPoint = updateBranchPoint(wire, originalWire);

                        // 更新终点位置
                        const endRect = wire.end.getBoundingClientRect();
                        const canvasRect = canvas.getBoundingClientRect();
                        const endX = endRect.left - canvasRect.left + endRect.width / 2;
                        const endY = endRect.top - canvasRect.top + endRect.height / 2;

                        updateWirePath(wire.line, updatedBranchPoint.x, updatedBranchPoint.y, endX, endY);

                        // 更新存储的分支点坐标
                        wire.branchPoint = updatedBranchPoint;
                    }
                } else if (wire.connectsTo && wire.start) {
                    // 从锚点连接到连线的情况
                    const targetWireData = wires.find(w => w.line === wire.connectsTo);
                    if (targetWireData && targetWireData.start && targetWireData.end) {
                        // 更新起点位置（锚点）
                        const startRect = wire.start.getBoundingClientRect();
                        const canvasRect = canvas.getBoundingClientRect();
                        const startX = startRect.left - canvasRect.left + startRect.width / 2;
                        const startY = startRect.top - canvasRect.top + startRect.height / 2;

                        // 根据比例计算目标连线上的连接点
                        const targetStartRect = targetWireData.start.getBoundingClientRect();
                        const targetEndRect = targetWireData.end.getBoundingClientRect();

                        const targetStartX = targetStartRect.left - canvasRect.left + targetStartRect.width / 2;
                        const targetStartY = targetStartRect.top - canvasRect.top + targetStartRect.height / 2;
                        const targetEndX = targetEndRect.left - canvasRect.left + targetEndRect.width / 2;
                        const targetEndY = targetEndRect.top - canvasRect.top + targetEndRect.height / 2;

                        const connectionX = targetStartX + (targetEndX - targetStartX) * wire.connectionRatio;
                        const connectionY = targetStartY + (targetEndY - targetStartY) * wire.connectionRatio;

                        updateWirePath(wire.line, startX, startY, connectionX, connectionY);

                        // 更新存储的连接点坐标
                        wire.connectionPoint = { x: connectionX, y: connectionY };
                    }
                } else if (wire.start && wire.end) {
                    // 普通连线：两端都是锚点
                    const startRect = wire.start.getBoundingClientRect();
                    const endRect = wire.end.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();

                    const startX = startRect.left - canvasRect.left + startRect.width / 2;
                    const startY = startRect.top - canvasRect.top + startRect.height / 2;
                    const endX = endRect.left - canvasRect.left + endRect.width / 2;
                    const endY = endRect.top - canvasRect.top + endRect.height / 2;

                    updateWirePath(wire.line, startX, startY, endX, endY);
                }
            }

            // 更新分支点位置的函数
            function updateBranchPoint(branchWire, originalWire) {
                if (!branchWire.branchRatio) {
                    // 如果没有存储分支比例，计算当前比例
                    if (originalWire.start && originalWire.end && branchWire.branchPoint) {
                        const startRect = originalWire.start.getBoundingClientRect();
                        const endRect = originalWire.end.getBoundingClientRect();
                        const canvasRect = canvas.getBoundingClientRect();

                        const startX = startRect.left - canvasRect.left + startRect.width / 2;
                        const startY = startRect.top - canvasRect.top + startRect.height / 2;
                        const endX = endRect.left - canvasRect.left + endRect.width / 2;
                        const endY = endRect.top - canvasRect.top + endRect.height / 2;

                        // 计算分支点在原连线上的比例
                        const totalLength = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                        const branchLength = Math.sqrt(Math.pow(branchWire.branchPoint.x - startX, 2) + Math.pow(branchWire.branchPoint.y - startY, 2));

                        branchWire.branchRatio = totalLength > 0 ? branchLength / totalLength : 0.5;
                    } else {
                        branchWire.branchRatio = 0.5; // 默认中点
                    }
                }

                // 根据当前原连线位置和存储的比例计算新的分支点
                if (originalWire.start && originalWire.end) {
                    const startRect = originalWire.start.getBoundingClientRect();
                    const endRect = originalWire.end.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();

                    const startX = startRect.left - canvasRect.left + startRect.width / 2;
                    const startY = startRect.top - canvasRect.top + startRect.height / 2;
                    const endX = endRect.left - canvasRect.left + endRect.width / 2;
                    const endY = endRect.top - canvasRect.top + endRect.height / 2;

                    // 根据比例计算新的分支点位置
                    const newX = startX + (endX - startX) * branchWire.branchRatio;
                    const newY = startY + (endY - startY) * branchWire.branchRatio;

                    return { x: newX, y: newY };
                } else if (originalWire.branchFrom) {
                    // 如果原连线也是分支连线，递归处理
                    const parentWire = wires.find(w => w.line === originalWire.branchFrom);
                    if (parentWire) {
                        const parentBranchPoint = updateBranchPoint(originalWire, parentWire);
                        return parentBranchPoint;
                    }
                }

                // 如果无法计算，返回原分支点
                return branchWire.branchPoint;
            }

            // 信号传播函数
            function propagateSignal(sourceComponent) {
                // 查找所有从sourceComponent出发的连线（包括锚点连接和分支连线）
                const outputAnchors = Array.from(sourceComponent.querySelectorAll('.output-anchor'));

                // 处理锚点连接 - 支持多个连接
                outputAnchors.forEach(anchor => {
                    // 为每个输出锚点获取对应的状态
                    const sourceState = getComponentOutputState(sourceComponent, anchor);

                    if (anchorConnections.has(anchor)) {
                        const targetAnchors = anchorConnections.get(anchor);
                        targetAnchors.forEach(targetAnchor => {
                            propagateToTarget(targetAnchor, sourceState);
                        });
                    }
                });

                // 处理分支连线
                const branchWires = wires.filter(wire => {
                    if (wire.branchFrom) {
                        // 找到分支源连线对应的源组件
                        const originalWire = wires.find(w => w.line === wire.branchFrom);
                        return originalWire && originalWire.start &&
                               originalWire.start.closest('.component') === sourceComponent;
                    }
                    return false;
                });

                branchWires.forEach(wire => {
                    if (wire.end) {
                        // 需要找到对应的输出锚点来获取正确的状态
                        const originalWire = wires.find(w => w.line === wire.branchFrom);
                        if (originalWire && originalWire.start) {
                            const sourceState = getComponentOutputState(sourceComponent, originalWire.start);
                            propagateToTarget(wire.end, sourceState);
                        }
                    }
                });

                // 处理连接到连线的情况（从锚点连接到连线）
                const connectingWires = wires.filter(wire => {
                    return wire.connectsTo && wire.start &&
                           wire.start.closest('.component') === sourceComponent;
                });

                connectingWires.forEach(wire => {
                    // 获取源锚点的状态
                    const sourceState = getComponentOutputState(sourceComponent, wire.start);

                    // 将信号传播到目标连线上的所有连接点
                    const targetWireData = wires.find(w => w.line === wire.connectsTo);
                    if (targetWireData) {
                        // 找到目标连线的终点并传播信号
                        if (targetWireData.end) {
                            propagateToTarget(targetWireData.end, sourceState);
                        }

                        // 找到所有从目标连线分支出去的连线并传播信号
                        const targetBranchWires = wires.filter(w => w.branchFrom === wire.connectsTo);
                        targetBranchWires.forEach(branchWire => {
                            if (branchWire.end) {
                                propagateToTarget(branchWire.end, sourceState);
                            }
                        });
                    }
                });
            }

            // 传播信号到目标锚点
            function propagateToTarget(targetAnchor, sourceState) {
                const targetComponent = targetAnchor.closest('.component');
                const targetType = targetComponent.dataset.type;

                // 根据目标元件类型处理信号
                if (targetType === 'input') {
                    // 输入端口不能接收信号
                    return;
                } else if (targetType === 'output') {
                    // 更新输出端口状态
                    const targetId = targetComponent.dataset.id;
                    componentStates.set(targetId, sourceState);
                    updateComponentDisplay(targetComponent, sourceState);
                } else if (isSequentialElement(targetType)) {
                    // 时序逻辑元件不响应普通信号传播，只响应时钟边沿
                    // 但是如果是D输入，我们需要记录当前值供时钟边沿时使用
                    if (targetType === 'd-flipflop' && !isClockInput(targetAnchor)) {

                        // 这里不立即更新输出，只记录输入状态
                    }
                    return;
                } else {
                    // 组合逻辑门
                    // 收集所有输入锚点的状态
                    const inputAnchors = Array.from(targetComponent.querySelectorAll('.input-anchor'));
                    const inputStates = inputAnchors.map(inputAnchor => {
                        let signalSources = [];

                        // 检查锚点连接 - 支持多个连接
                        if (anchorConnections.has(inputAnchor)) {
                            const sourceAnchors = anchorConnections.get(inputAnchor);
                            console.log(`输入锚点有 ${sourceAnchors.length} 个连接`);
                            sourceAnchors.forEach(sourceAnchor => {
                                const sourceComp = sourceAnchor.closest('.component');
                                const state = getComponentOutputState(sourceComp, sourceAnchor);
                                console.log(`从 ${sourceComp.dataset.type} 获取状态:`, state);
                                signalSources.push(state);
                            });
                        } else {
                            console.log('输入锚点没有在 anchorConnections 中找到连接');
                        }

                        // 检查分支连线
                        const branchWire = wires.find(wire => wire.end === inputAnchor && wire.branchFrom);
                        if (branchWire) {
                            const originalWire = wires.find(w => w.line === branchWire.branchFrom);
                            if (originalWire && originalWire.start) {
                                const sourceComp = originalWire.start.closest('.component');
                                signalSources.push(getComponentOutputState(sourceComp, originalWire.start));
                            }
                        }

                        // 检查是否有多个连线连接到同一个输入锚点
                        const multipleConnections = wires.filter(wire => wire.end === inputAnchor);
                        multipleConnections.forEach(wire => {
                            if (wire.start && !signalSources.length) { // 避免重复计算
                                const sourceComp = wire.start.closest('.component');
                                signalSources.push(getComponentOutputState(sourceComp, wire.start));
                            }
                        });

                        // 检查是否有连线连接到包含此锚点的连线上
                        const parentWires = wires.filter(wire => wire.end === inputAnchor);
                        parentWires.forEach(parentWire => {
                            if (parentWire.line) {
                                // 查找连接到这条连线的其他连线
                                const connectingWires = wires.filter(w => w.connectsTo === parentWire.line);
                                connectingWires.forEach(connectingWire => {
                                    if (connectingWire.start) {
                                        const sourceComp = connectingWire.start.closest('.component');
                                        signalSources.push(getComponentOutputState(sourceComp, connectingWire.start));
                                    }
                                });
                            }
                        });

                        // 如果有多个信号源，进行逻辑OR操作（线或）
                        if (signalSources.length > 1) {
                            console.log(`输入锚点有${signalSources.length}个信号源，进行线或操作`);
                            return signalSources.some(state => state === 1) ? 1 : 0;
                        } else if (signalSources.length === 1) {
                            return signalSources[0];
                        }

                        return 0; // 默认无连接为低电平
                    });

                    // 计算逻辑门输出
                    console.log(`逻辑门 ${targetType} 输入状态:`, inputStates);
                    const outputState = logicFunctions[targetType](inputStates);
                    console.log(`逻辑门 ${targetType} 输出状态:`, outputState);
                    const targetId = targetComponent.dataset.id;

                    // 处理多输出运算器
                    if (['adder', 'subtractor', 'divider'].includes(targetType)) {
                        // 运算器有多个输出，需要分别存储
                        componentStates.set(targetId, outputState);
                        updateArithmeticComponentDisplay(targetComponent, outputState, targetType);
                    } else {
                        // 普通逻辑门只有一个输出
                        componentStates.set(targetId, outputState);
                        updateComponentDisplay(targetComponent, outputState);
                    }

                    // 继续传播信号
                    propagateSignal(targetComponent);
                }
            }
            
            // 获取元件输出状态
            function getComponentOutputState(component, outputAnchor = null) {
                const id = component.dataset.id;
                const type = component.dataset.type;

                if (type === 'input' || type === 'output' || type === 'clock' || type === 'push-button' || type === 'switch') {
                    const state = componentStates.get(id);
                    console.log(`getComponentOutputState for ${type} (ID: ${id}):`, state);
                    return state;
                } else if (['adder', 'subtractor', 'divider'].includes(type)) {
                    // 运算器有多个输出，需要根据输出锚点确定返回哪个值
                    const state = componentStates.get(id);
                    if (!state || !outputAnchor) return 0;

                    // 根据锚点位置确定输出类型
                    const anchorY = parseInt(outputAnchor.getAttribute('cy'));
                    if (type === 'adder') {
                        return anchorY === 50 ? state.sum : state.carry;
                    } else if (type === 'subtractor') {
                        return anchorY === 50 ? state.difference : state.borrow;
                    } else if (type === 'divider') {
                        return anchorY === 50 ? state.quotient : state.remainder;
                    }
                    return 0;
                } else {
                    // 普通逻辑门和求补器
                    return componentStates.get(id) || 0;
                }
            }
            
            // 更新元件显示
            function updateComponentDisplay(component, state) {
                const type = component.dataset.type;

                if (type === 'output') {
                    const textElement = component.querySelector('.state-text');
                    const bgElement = component.querySelector('#output-bg');

                    if (textElement) textElement.textContent = state ? "1" : "0";
                    if (bgElement) {
                        bgElement.classList.remove(state ? 'state-0' : 'state-1');
                        bgElement.classList.add(state ? 'state-1' : 'state-0');
                    }
                } else if (type === 'd-flipflop') {
                    // 更新D触发器的显示状态
                    const qText = component.querySelector('text[x="185"][y="55"]');
                    const qBarText = component.querySelector('text[x="185"][y="75"]');

                    if (qText) {
                        qText.textContent = `Q=${state}`;
                    }
                    if (qBarText) {
                        qBarText.textContent = `Q̄=${1-state}`;
                    }

                    // 可以添加颜色变化来表示状态
                    const rect = component.querySelector('rect');
                    if (rect) {
                        rect.setAttribute('fill', state ? '#e8f5e8' : '#f5e8e8');
                    }
                }
            }

            // 更新运算器组件显示
            function updateArithmeticComponentDisplay(component, state, type) {
                if (type === 'adder') {
                    // 更新加法器显示
                    const sumText = component.querySelector('text[x="185"][y="55"]');
                    const carryText = component.querySelector('text[x="185"][y="75"]');

                    if (sumText) sumText.textContent = `S=${state.sum}`;
                    if (carryText) carryText.textContent = `Cout=${state.carry}`;
                } else if (type === 'subtractor') {
                    // 更新减法器显示
                    const diffText = component.querySelector('text[x="185"][y="55"]');
                    const borrowText = component.querySelector('text[x="185"][y="75"]');

                    if (diffText) diffText.textContent = `D=${state.difference}`;
                    if (borrowText) borrowText.textContent = `Bout=${state.borrow}`;
                } else if (type === 'divider') {
                    // 更新除法器显示
                    const quotientText = component.querySelector('text[x="185"][y="55"]');
                    const remainderText = component.querySelector('text[x="185"][y="75"]');

                    if (quotientText) quotientText.textContent = `Q=${state.quotient}`;
                    if (remainderText) remainderText.textContent = `R=${state.remainder}`;
                }
            }

            // 时钟信号管理
            const clockIntervals = new Map(); // 存储每个时钟的定时器
            const clockPreviousStates = new Map(); // 存储时钟的前一个状态，用于边沿检测

            // 启动时钟信号
            function startClockSignal(clockComponent) {
                const id = clockComponent.dataset.id;
                const frequency = 1000; // 1秒周期

                // 清除可能存在的旧定时器
                if (clockIntervals.has(id)) {
                    clearInterval(clockIntervals.get(id));
                }

                // 创建新的定时器
                const interval = setInterval(() => {
                    const currentState = componentStates.get(id);
                    const previousState = clockPreviousStates.get(id) || 0;
                    const newState = currentState === 0 ? 1 : 0;

                    // 先进行边沿检测（在更新前状态之前）
                    const isRisingEdge = previousState === 0 && newState === 1;
                    const isFallingEdge = previousState === 1 && newState === 0;

                    // 然后更新状态
                    componentStates.set(id, newState);
                    // 更新前状态为新状态（供下次边沿检测使用）
                    clockPreviousStates.set(id, newState);

                    // 更新时钟显示
                    const bgElement = clockComponent.querySelector('#clock-bg');
                    if (bgElement) {
                        if (newState === 1) {
                            bgElement.classList.add('clock-active');
                        } else {
                            bgElement.classList.remove('clock-active');
                        }
                    }

                    if (isRisingEdge || isFallingEdge) {

                        // 记录时钟边沿事件
                        clockEdgeDetection.set(id, {
                            edgeType: isRisingEdge ? 'rising' : 'falling',
                            timestamp: Date.now(),
                            clockState: newState
                        });

                        // 处理时序逻辑更新（延迟执行，模拟真实的传播延迟）
                        setTimeout(() => {
                            processSequentialLogic(clockComponent, isRisingEdge ? 'rising' : 'falling');


                        }, 5); // 减少延迟到5ms
                    }

                    // 对于组合逻辑元件，使用普通的信号传播
                    propagateSignal(clockComponent);
                }, frequency);

                clockIntervals.set(id, interval);
            }

            // 真正的时序逻辑处理函数
            function processSequentialLogic(clockComponent, edgeType) {
                // 找到所有连接到此时钟的时序元件
                const connectedSequentialElements = findConnectedSequentialElements(clockComponent);

                // 去重处理，避免重复处理同一个元件
                const processedElements = new Set();
                connectedSequentialElements.forEach(element => {
                    const elementType = element.dataset.type;
                    const elementId = element.dataset.id;

                    if (processedElements.has(elementId)) {
                        return;
                    }

                    processedElements.add(elementId);

                    if (elementType === 'd-flipflop') {
                        processDFlipFlop(element, edgeType);
                    }
                    // 可以在这里添加其他时序元件的处理
                });
            }

            // 查找连接到时钟的时序元件
            function findConnectedSequentialElements(clockComponent) {
                const connectedElements = [];
                const outputAnchors = Array.from(clockComponent.querySelectorAll('.output-anchor'));

                outputAnchors.forEach(anchor => {
                    // 检查直接连接 - 支持多个连接
                    if (anchorConnections.has(anchor)) {
                        const targetAnchors = anchorConnections.get(anchor);
                        targetAnchors.forEach(targetAnchor => {
                            const targetComponent = targetAnchor.closest('.component');
                            const targetType = targetComponent.dataset.type;

                            // 检查目标锚点是否是时钟输入
                            if (isSequentialElement(targetType) && isClockInput(targetAnchor)) {
                                connectedElements.push(targetComponent);
                            }
                        });
                    }

                    // 检查通过连线的连接
                    wires.forEach(wire => {
                        if (wire.start === anchor && wire.end) {
                            const targetComponent = wire.end.closest('.component');
                            const targetType = targetComponent.dataset.type;

                            if (isSequentialElement(targetType) && isClockInput(wire.end)) {
                                connectedElements.push(targetComponent);
                            }
                        }
                    });
                });

                return connectedElements;
            }

            // 判断是否是时序元件
            function isSequentialElement(componentType) {
                return componentType === 'd-flipflop' || componentType === 'jk-flipflop' || componentType === 'sr-flipflop';
            }

            // 判断是否是时钟输入锚点
            function isClockInput(anchor) {
                return anchor.getAttribute('data-anchor-type') === 'clock' ||
                       anchor.classList.contains('clock-input');
            }

            // D触发器的真正时序逻辑处理
            function processDFlipFlop(flipflopComponent, edgeType) {
                const componentId = flipflopComponent.dataset.id;

                // D触发器只在上升沿触发
                if (edgeType !== 'rising') {
                    return;
                }

                // 获取D输入的当前状态
                const dInputState = getDFlipFlopInputState(flipflopComponent);

                // 获取或初始化D触发器状态
                if (!sequentialElements.has(componentId)) {
                    sequentialElements.set(componentId, {
                        q: 0,
                        qBar: 1,
                        lastD: 0,
                        lastClock: 0
                    });
                }

                const flipflopState = sequentialElements.get(componentId);

                // 在上升沿时，将D输入锁存到Q输出
                const newQ = dInputState;
                const newQBar = 1 - dInputState;

                // 更新内部状态
                flipflopState.q = newQ;
                flipflopState.qBar = newQBar;
                flipflopState.lastD = dInputState;
                flipflopState.lastClock = 1;

                // 更新组件状态（用于显示）
                componentStates.set(componentId, newQ);

                // 更新显示
                updateDFlipFlopDisplay(flipflopComponent, newQ, newQBar);

                // 传播输出信号到连接的元件
                propagateDFlipFlopOutputs(flipflopComponent, newQ, newQBar);

                // 强制刷新所有连接的输出端口显示
                setTimeout(() => {
                    refreshAllComponentDisplays();
                }, 20);
            }

            // 获取D触发器的D输入状态
            function getDFlipFlopInputState(flipflopComponent) {
                const inputAnchors = Array.from(flipflopComponent.querySelectorAll('.input-anchor'));

                // 找到D输入锚点（不是时钟输入）
                const dInputAnchor = inputAnchors.find(anchor =>
                    !isClockInput(anchor)
                );

                if (!dInputAnchor) {
                    return 0;
                }

                // 检查连接到D输入的信号 - 支持多个连接，取第一个有效信号
                if (anchorConnections.has(dInputAnchor)) {
                    const sourceAnchors = anchorConnections.get(dInputAnchor);
                    for (const sourceAnchor of sourceAnchors) {
                        const sourceComponent = sourceAnchor.closest('.component');
                        const state = getComponentOutputState(sourceComponent, sourceAnchor);
                        if (state !== undefined) {
                            return state;
                        }
                    }
                }

                // 检查通过连线连接的信号
                const connectedWire = wires.find(wire => wire.end === dInputAnchor);
                if (connectedWire && connectedWire.start) {
                    const sourceComponent = connectedWire.start.closest('.component');
                    return getComponentOutputState(sourceComponent, connectedWire.start);
                }

                return 0; // 默认为0
            }

            // 更新D触发器的显示
            function updateDFlipFlopDisplay(flipflopComponent, qState, qBarState) {
                // 更新组件背景色表示状态
                const rect = flipflopComponent.querySelector('rect');
                if (rect) {
                    rect.setAttribute('fill', qState ? '#e8f5e8' : '#f5e8e8');
                }

                // 可以添加文本显示当前状态
                const texts = flipflopComponent.querySelectorAll('text');
                texts.forEach(text => {
                    if (text.textContent === 'D') {
                        // 可以在这里添加D输入状态显示
                    } else if (text.textContent === 'FF') {
                        text.textContent = `Q=${qState}`;
                    }
                });
            }

            // 传播D触发器的输出信号
            function propagateDFlipFlopOutputs(flipflopComponent, qState, qBarState) {
                const outputAnchors = Array.from(flipflopComponent.querySelectorAll('.output-anchor'));

                outputAnchors.forEach((anchor, index) => {
                    const outputValue = index === 0 ? qState : qBarState; // 第一个输出是Q，第二个是Q̄

                    // 传播到直接连接的锚点 - 支持多个连接
                    if (anchorConnections.has(anchor)) {
                        const targetAnchors = anchorConnections.get(anchor);
                        targetAnchors.forEach(targetAnchor => {
                            const targetComponent = targetAnchor.closest('.component');
                            const targetType = targetComponent.dataset.type;

                            // 只传播到组合逻辑元件，时序逻辑元件由时钟边沿控制
                            if (!isSequentialElement(targetType)) {
                                propagateToTarget(targetAnchor, outputValue);
                            }
                        });
                    }

                    // 传播到通过连线连接的元件
                    wires.forEach(wire => {
                        if (wire.start === anchor && wire.end) {
                            const targetComponent = wire.end.closest('.component');
                            const targetType = targetComponent.dataset.type;

                            if (!isSequentialElement(targetType)) {
                                propagateToTarget(wire.end, outputValue);
                            }
                        }
                    });
                });
            }

            // 刷新所有组件显示
            function refreshAllComponentDisplays() {
                const allComponents = document.querySelectorAll('.component');
                allComponents.forEach(component => {
                    const componentId = component.dataset.id;
                    const currentState = componentStates.get(componentId);
                    if (currentState !== undefined) {
                        updateComponentDisplay(component, currentState);
                    }
                });
            }

            // 停止时钟信号
            function stopClockSignal(clockComponent) {
                const id = clockComponent.dataset.id;
                if (clockIntervals.has(id)) {
                    clearInterval(clockIntervals.get(id));
                    clockIntervals.delete(id);
                }
            }

            // 设置时钟频率
            function setClockFrequency(clockComponent, frequency) {
                stopClockSignal(clockComponent);
                // 重新启动时钟，但需要修改频率参数
                const id = clockComponent.dataset.id;
                const interval = setInterval(() => {
                    const currentState = componentStates.get(id);
                    const newState = currentState === 0 ? 1 : 0;
                    componentStates.set(id, newState);

                    const bgElement = clockComponent.querySelector('#clock-bg');
                    if (bgElement) {
                        if (newState === 1) {
                            bgElement.classList.add('clock-active');
                        } else {
                            bgElement.classList.remove('clock-active');
                        }
                    }

                    propagateSignal(clockComponent);
                }, frequency);

                clockIntervals.set(id, interval);
            }

            // 删除功能
            // 选择元素
            function selectElement(element) {
                // 清除之前的选择
                if (selectedElement) {
                    selectedElement.classList.remove('selected');
                }

                selectedElement = element;
                element.classList.add('selected');
            }

            // 显示右键菜单
            function showContextMenu(x, y) {
                // 清除之前的动态菜单项
                const dynamicItems = contextMenu.querySelectorAll('.dynamic-item');
                dynamicItems.forEach(item => item.remove());

                // 如果选中的是按钮，添加配置选项
                if (selectedElement && selectedElement.dataset.type === 'push-button') {
                    const id = selectedElement.dataset.id;
                    const currentConfig = typeof getButtonConfig === 'function' ? getButtonConfig(id) : { trigger: 'high' };

                    const configItem = document.createElement('div');
                    configItem.className = 'context-menu-item dynamic-item';
                    configItem.innerHTML = `<span>触发模式: ${getTriggerModeName(currentConfig.trigger)}</span>`;

                    const subMenu = document.createElement('div');
                    subMenu.className = 'context-submenu';

                    const modes = [
                        { value: 'high', name: '高电平' },
                        { value: 'low', name: '低电平' },
                        { value: 'rising', name: '上升沿' },
                        { value: 'falling', name: '下降沿' }
                    ];

                    modes.forEach(mode => {
                        const subMenuItem = document.createElement('div');
                        subMenuItem.className = 'context-submenu-item';
                        subMenuItem.textContent = mode.name;
                        if (mode.value === currentConfig.trigger) {
                            subMenuItem.classList.add('active');
                        }
                        subMenuItem.addEventListener('click', (e) => {
                            e.stopPropagation();
                            if (typeof setButtonConfig === 'function') {
                                setButtonConfig(id, { trigger: mode.value });
                            }
                            hideContextMenu();
                        });
                        subMenu.appendChild(subMenuItem);
                    });

                    configItem.appendChild(subMenu);
                    contextMenu.appendChild(configItem);
                }

                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                contextMenu.style.display = 'block';
            }

            // 获取触发模式的中文名称
            function getTriggerModeName(trigger) {
                const names = {
                    'high': '高电平',
                    'low': '低电平',
                    'rising': '上升沿',
                    'falling': '下降沿'
                };
                return names[trigger] || '高电平';
            }

            // 隐藏右键菜单
            function hideContextMenu() {
                contextMenu.style.display = 'none';
            }

            // 删除选中的元素
            function deleteSelectedElement() {
                if (!selectedElement) return;

                console.log('删除元素:', selectedElement.className);

                if (selectedElement.classList.contains('component')) {
                    deleteComponent(selectedElement);
                } else if (selectedElement.classList.contains('wire')) {
                    deleteWire(selectedElement);
                } else if (selectedElement.classList.contains('text-element')) {
                    deleteTextElement(selectedElement);
                    console.log('删除文字元素');
                }

                selectedElement = null;
                hideContextMenu();
            }

            // 删除文字元素
            function deleteTextElement(textElement) {
                if (textElement && textElement.parentNode) {
                    textElement.parentNode.removeChild(textElement);
                }
            }

            // 删除元件
            function deleteComponent(component) {
                const id = component.dataset.id;
                const type = component.dataset.type;

                // 停止时钟信号（如果是时钟元件）
                if (type === 'clock') {
                    stopClockSignal(component);
                }

                // 删除与该元件相关的所有连线
                const relatedWires = [];
                wires.forEach((wire, index) => {
                    if ((wire.start && wire.start.closest('.component') === component) ||
                        (wire.end && wire.end.closest('.component') === component)) {
                        relatedWires.push(index);
                    }
                });

                // 从后往前删除，避免索引问题
                relatedWires.reverse().forEach(index => {
                    const wire = wires[index];
                    // 删除锚点连接关系 - 支持多个连接
                    if (wire.start && wire.end) {
                        // 从起始锚点的连接列表中移除目标锚点
                        if (anchorConnections.has(wire.start)) {
                            const startConnections = anchorConnections.get(wire.start);
                            const targetIndex = startConnections.indexOf(wire.end);
                            if (targetIndex > -1) {
                                startConnections.splice(targetIndex, 1);
                            }
                            // 如果连接列表为空，删除整个条目
                            if (startConnections.length === 0) {
                                anchorConnections.delete(wire.start);
                            }
                        }

                        // 从目标锚点的连接列表中移除起始锚点
                        if (anchorConnections.has(wire.end)) {
                            const endConnections = anchorConnections.get(wire.end);
                            const startIndex = endConnections.indexOf(wire.start);
                            if (startIndex > -1) {
                                endConnections.splice(startIndex, 1);
                            }
                            // 如果连接列表为空，删除整个条目
                            if (endConnections.length === 0) {
                                anchorConnections.delete(wire.end);
                            }
                        }
                    }
                    // 删除连线元素
                    if (wire.line.parentNode) {
                        wire.line.parentNode.removeChild(wire.line);
                    }
                    // 从数组中删除
                    wires.splice(index, 1);
                });

                // 删除元件状态
                componentStates.delete(id);

                // 删除元件DOM元素
                if (component.parentNode) {
                    component.parentNode.removeChild(component);
                }


            }

            // 删除连线
            function deleteWire(wireElement) {
                const wireIndex = wires.findIndex(wire => wire.line === wireElement);
                if (wireIndex === -1) return;

                const wire = wires[wireIndex];

                // 删除锚点连接关系 - 支持多个连接
                if (wire.start && wire.end) {
                    // 从起始锚点的连接列表中移除目标锚点
                    if (anchorConnections.has(wire.start)) {
                        const startConnections = anchorConnections.get(wire.start);
                        const targetIndex = startConnections.indexOf(wire.end);
                        if (targetIndex > -1) {
                            startConnections.splice(targetIndex, 1);
                        }
                        // 如果连接列表为空，删除整个条目
                        if (startConnections.length === 0) {
                            anchorConnections.delete(wire.start);
                        }
                    }

                    // 从目标锚点的连接列表中移除起始锚点
                    if (anchorConnections.has(wire.end)) {
                        const endConnections = anchorConnections.get(wire.end);
                        const startIndex = endConnections.indexOf(wire.start);
                        if (startIndex > -1) {
                            endConnections.splice(startIndex, 1);
                        }
                        // 如果连接列表为空，删除整个条目
                        if (endConnections.length === 0) {
                            anchorConnections.delete(wire.end);
                        }
                    }
                }

                // 删除所有以此连线为分支源的分支连线
                const branchWires = wires.filter(w => w.branchFrom === wireElement);
                branchWires.forEach(branchWire => {
                    if (branchWire.line.parentNode) {
                        branchWire.line.parentNode.removeChild(branchWire.line);
                    }
                });

                // 删除所有连接到此连线的连线
                const connectingWires = wires.filter(w => w.connectsTo === wireElement);
                connectingWires.forEach(connectingWire => {
                    if (connectingWire.line.parentNode) {
                        connectingWire.line.parentNode.removeChild(connectingWire.line);
                    }
                });

                // 从数组中删除所有相关连线
                for (let i = wires.length - 1; i >= 0; i--) {
                    const w = wires[i];
                    if (w.line === wireElement || w.branchFrom === wireElement || w.connectsTo === wireElement) {
                        wires.splice(i, 1);
                    }
                }

                // 删除连线DOM元素
                if (wireElement.parentNode) {
                    wireElement.parentNode.removeChild(wireElement);
                }


            }

            // 事件监听器
            // 点击空白区域取消选择
            canvas.addEventListener('click', function (e) {
                if (e.target === canvas || e.target === wireLayer) {
                    if (selectedElement) {
                        selectedElement.classList.remove('selected');
                        selectedElement = null;
                    }
                    hideContextMenu();
                }
            });

            // 点击其他地方隐藏右键菜单
            document.addEventListener('click', function (e) {
                if (!contextMenu.contains(e.target)) {
                    hideContextMenu();
                }
            });

            // 右键菜单项点击事件
            deleteItem.addEventListener('click', function () {
                deleteSelectedElement();
            });

            // 键盘控制功能
            document.addEventListener('keydown', function (e) {
                // 删除功能
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (selectedElement) {
                        e.preventDefault();
                        deleteSelectedElement();
                    }
                }
                // 旋转功能
                else if (selectedElement && selectedElement.classList.contains('component')) {
                    const svg = selectedElement.querySelector('svg');
                    if (!svg) return;
                    
                    let rotation = parseInt(selectedElement.dataset.rotation) || 0;
                    const scale = parseFloat(selectedElement.dataset.scale) || 1;
                    
                    if (e.key === 'ArrowUp') {
                        rotation = (rotation + 90) % 360;
                    } else if (e.key === 'ArrowDown') {
                        rotation = (rotation - 90) % 360;
                    } else {
                        return;
                    }
                    
                    e.preventDefault();
                    selectedElement.dataset.rotation = rotation;
                    svg.style.transform = `rotate(${rotation}deg) scale(${scale})`;
                    
                    // 更新所有连线位置
                    wires.forEach(wire => {
                        if (wire.start && wire.start.closest('.component') === selectedElement || 
                            wire.end && wire.end.closest('.component') === selectedElement) {
                            updateWirePosition(wire);
                        }
                    });
                }
            });

            // 画布点击事件 - 处理文字工具和取消选择
            canvas.addEventListener('click', function(e) {
                if (currentTool === 'text') {
                    // 确保点击的是画布空白区域，不是元件或连线
                    if (e.target === canvas || e.target.id === 'circuit-canvas') {
                        const canvasRect = canvas.getBoundingClientRect();
                        const x = e.clientX - canvasRect.left;
                        const y = e.clientY - canvasRect.top;

                        createTextElement(x, y);

                        // 重置工具状态
                        toolbarItems.forEach(t => t.classList.remove('active'));
                        currentTool = null;
                        canvas.style.cursor = 'default';
                    }
                } else {
                    // 点击空白区域取消选择
                    if (e.target === canvas || e.target.id === 'circuit-canvas') {
                        if (selectedElement) {
                            selectedElement.classList.remove('selected');
                            selectedElement = null;
                        }
                        // 取消工具选择
                        if (currentTool) {
                            toolbarItems.forEach(t => t.classList.remove('active'));
                            currentTool = null;
                            canvas.style.cursor = 'default';
                        }
                    }
                }
            });

            // 创建文字元素的函数
            function createTextElement(x, y) {
                const textDiv = document.createElement('div');
                textDiv.className = 'text-element';
                textDiv.style.position = 'absolute';
                textDiv.style.left = x + 'px';
                textDiv.style.top = y + 'px';
                textDiv.style.fontSize = '14px';
                textDiv.style.fontFamily = 'Arial, sans-serif';
                textDiv.style.color = '#000';
                textDiv.style.background = 'rgba(255, 255, 255, 0.8)';
                textDiv.style.padding = '2px 4px';
                textDiv.style.border = '1px dashed #ccc';
                textDiv.style.borderRadius = '3px';
                textDiv.style.cursor = 'move';
                textDiv.style.minWidth = '20px'; // 减小最小宽度
                textDiv.style.width = 'auto'; // 自动宽度
                textDiv.style.display = 'inline-block'; // 使用inline-block以适应内容
                textDiv.style.whiteSpace = 'nowrap'; // 防止换行
                textDiv.style.zIndex = '15';
                textDiv.contentEditable = true;
                textDiv.textContent = '文字';

                canvas.appendChild(textDiv);

                // 初始调整大小
                adjustTextElementSize(textDiv);

                // 自动选中文字进行编辑
                textDiv.focus();
                // 选中所有文字内容
                setTimeout(() => {
                    const range = document.createRange();
                    range.selectNodeContents(textDiv);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                }, 0);

                // 添加文字元素的事件监听器
                addTextElementEventListeners(textDiv);
            }

            // 调整文字元素大小以适应内容
            function adjustTextElementSize(textDiv) {
                // 创建一个临时的测量元素
                const measurer = document.createElement('div');
                measurer.style.position = 'absolute';
                measurer.style.visibility = 'hidden';
                measurer.style.whiteSpace = 'nowrap';
                measurer.style.fontSize = textDiv.style.fontSize;
                measurer.style.fontFamily = textDiv.style.fontFamily;
                measurer.style.padding = textDiv.style.padding;
                measurer.textContent = textDiv.textContent || '文字';

                document.body.appendChild(measurer);

                // 获取实际需要的宽度
                const contentWidth = measurer.offsetWidth;

                // 设置最小宽度为20px，实际宽度为内容宽度
                const finalWidth = Math.max(20, contentWidth);
                textDiv.style.width = finalWidth + 'px';

                // 清理临时元素
                document.body.removeChild(measurer);
            }

            // 添加文字元素事件监听器
            function addTextElementEventListeners(textDiv) {
                let isDragging = false;
                let startX, startY;
                let startLeft, startTop;

                // 鼠标按下事件
                textDiv.addEventListener('mousedown', function(e) {
                    // 只有在非编辑状态下才能拖动
                    if (!textDiv.matches(':focus')) {
                        isDragging = true;
                        startX = e.clientX;
                        startY = e.clientY;
                        startLeft = parseInt(textDiv.style.left) || 0;
                        startTop = parseInt(textDiv.style.top) || 0;
                        textDiv.style.cursor = 'grabbing';
                        e.preventDefault();
                        e.stopPropagation();

                        // 选择文字元素
                        selectElement(textDiv);
                    }
                });

                // 鼠标移动事件
                document.addEventListener('mousemove', function(e) {
                    if (!isDragging) return;

                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    let newLeft = startLeft + deltaX;
                    let newTop = startTop + deltaY;

                    // 限制在画布内
                    const canvasRect = canvas.getBoundingClientRect();
                    newLeft = Math.max(0, Math.min(newLeft, canvasRect.width - textDiv.offsetWidth));
                    newTop = Math.max(0, Math.min(newTop, canvasRect.height - textDiv.offsetHeight));

                    textDiv.style.left = newLeft + 'px';
                    textDiv.style.top = newTop + 'px';
                });

                // 鼠标释放事件
                document.addEventListener('mouseup', function() {
                    if (isDragging) {
                        isDragging = false;
                        textDiv.style.cursor = 'move';
                    }
                });

                // 右键菜单
                textDiv.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    selectElement(textDiv);
                    showContextMenu(e.clientX, e.clientY);
                });

                // 点击选择和编辑
                textDiv.addEventListener('click', function(e) {
                    e.stopPropagation();
                    selectElement(textDiv);

                    // 双击进入编辑模式
                    if (e.detail === 2) {
                        textDiv.focus();
                        // 选中所有文字
                        setTimeout(() => {
                            const range = document.createRange();
                            range.selectNodeContents(textDiv);
                            const selection = window.getSelection();
                            selection.removeAllRanges();
                            selection.addRange(range);
                        }, 0);
                    }
                });

                // 编辑完成时的处理
                textDiv.addEventListener('blur', function() {
                    if (textDiv.textContent.trim() === '') {
                        textDiv.textContent = '文字';
                    }
                    // 编辑完成后调整大小
                    adjustTextElementSize(textDiv);
                });

                // 输入事件 - 实时调整大小
                textDiv.addEventListener('input', function() {
                    adjustTextElementSize(textDiv);
                });

                // 按键处理
                textDiv.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        textDiv.blur(); // 完成编辑
                        e.preventDefault();
                    } else if (e.key === 'Escape') {
                        textDiv.blur(); // 取消编辑
                        e.preventDefault();
                    }
                    e.stopPropagation(); // 防止触发全局按键事件
                });

                // 按键释放后也调整大小（处理删除等操作）
                textDiv.addEventListener('keyup', function(e) {
                    // 延迟调整，确保内容已更新
                    setTimeout(() => {
                        adjustTextElementSize(textDiv);
                    }, 0);
                });
            }



            // 阻止浏览器默认右键菜单  第二版
            canvas.addEventListener('contextmenu', function (e) {
                e.preventDefault();
            });
        });
    </script>
</body>

</html>